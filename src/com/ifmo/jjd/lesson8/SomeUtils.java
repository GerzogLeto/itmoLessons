package com.ifmo.jjd.lesson8;
// Ключевое слово final можно использовать с:
// 1. классами - от final класса нельзя наследоваться
// 2. свойствами / поля / атрибуты - final свойства не могут быть изменены, их значения должны задаваться при объявлении или в конструкторе
// 3. методами - final методы нельзя переопределять в дочерних классах
// 4. аргументами методов - final аргументы доступны только для чтения
// 5. переменными

// Ключевое слово static можно использовать с
// 1. классами (только вложенными)
// 2. со свойствами
// 3. с методами
// в таком случае свойства и методы не принадлежат объектам, а принадлежат самому классу

// final и static можно использовать вместе

import java.util.Arrays;

public class SomeUtils {

    // static свойства принадлежит классу и не являются характеристиками объектов
    // свойство final static должно быть инициализировано при объявлении или в статическом блоке
    static final double E_VAR = 2.718; // (при объявлении)
    static final double T_VAR; // (в статическом блоке)
    static double counter = 1;

    // статический блок используется для инициализации статических свойств, вызова статических методов
    // код статического блока выполняется один раз, когда класс загружается в память первый раз
    static {
        T_VAR = 6.283; // (в статическом блоке)
        counter++;
    }

    // final свойство обязаны определить в конструкторе или при объявлении и нельзя изменить после
    private final String prefix; // (в конструкторе)
    private final double pi = 3.14; // (при объявлении)

    public SomeUtils(String prefix) {
        this.prefix = prefix;
    }

    // final метод нельзя будет переопределить в дочерних классах
    public final void someVoid(final int num, final int[] nums) {
        // final аргументы доступны только для чтения:
        System.out.println("num = " + num);
        // num = 90; нет возможность изменить final аргумент

        // для ссылочных типов это означает, что мы не может изменить ссылку, но можем по этой ссылки менять свойства объекта:
        // nums = new int[]{};
        nums[0] = 122;
        System.out.println(Arrays.toString(nums));
    }

    // статический метод принадлежит классу и не описывает возможности объектов
    // статическими могут быть фабричные методы (которые создают объекты)
    // или утилитарные (вспомогательные методы), например методы класса Arrays, Objects, Math и тд
    public static int sum(int a, int b) {
        // из статических методов нельзя обращаться к нестатическим свойствам и методам
        return a + b;
    }

    public static void main(String[] args) {
        // обращение к статическому свойству: ИмяКласса.имяСвойства
        System.out.println(SomeUtils.E_VAR);

        // вызов статического метода: ИмяКласса.имяМетода();
        System.out.println(SomeUtils.sum(45, 89));
    }
}

// final класс MyUtils является конечным и не может иметь потомков
final class MyUtils extends SomeUtils {

    public MyUtils(String prefix) {
        super(prefix);
    }

    // переопределение final метода запрещено в дочерних классах
    // @Override
    // public final void someVoid(final int num, final int[] nums) { }
}

// наследование от final класса запрещено
// class CustomUtils extends MyUtils{}


